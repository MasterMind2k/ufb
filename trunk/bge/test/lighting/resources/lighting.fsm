varying vec4 diffuse[5], ambientGlobal, ambient[5];
varying vec3 normal, lightDir[5], halfVector[5];
varying float dist[5];

vec4 calculateLighting()
{
  vec4 color = ambientGlobal;
  for (int i = 0; i < 5; i++) {
    vec3 n, halfV, viewV, ldir;
    float NdotL, NdotHV;
    float att, spotEffect;
    vec4 currentColor = vec4(0, 0, 0, 0);

    /* a fragment shader can't write a varying variable, hence we need
    a new variable to store the normalized interpolated normal */
    n = normalize(normal);
    
    /* compute the dot product between normal and normalized lightdir */
    NdotL = max(dot(n, normalize(lightDir[i])), 0.0);
  
    if (NdotL > 0.0) {

      if (gl_LightSource[i].spotCutoff != 180) {
        spotEffect = dot(normalize(gl_LightSource[i].spotDirection), 
        normalize(-lightDir[i]));
        if (spotEffect > gl_LightSource[i].spotCosCutoff) {

          spotEffect = pow(spotEffect, gl_LightSource[i].spotExponent);
          att = spotEffect / (gl_LightSource[i].constantAttenuation +
                gl_LightSource[i].linearAttenuation * dist[i] +
                gl_LightSource[i].quadraticAttenuation * dist[i] * dist[i]);
      
          currentColor += att * (diffuse[i] * NdotL + ambient[i]);
          halfV = normalize(halfVector[i]);
          NdotHV = max(dot(n, halfV), 0.0);
          currentColor += att * gl_FrontMaterial.specular * 
                   gl_LightSource[i].specular * 
                   pow(NdotHV, gl_FrontMaterial.shininess);

          color += currentColor;
        }

      } else {

        att = 1.0 / (gl_LightSource[i].constantAttenuation +
              gl_LightSource[i].linearAttenuation * dist[i] +
              gl_LightSource[i].quadraticAttenuation * dist[i] * dist[i]);
        currentColor += att * (diffuse[i] * NdotL + ambient[i]);
    
      
        halfV = normalize(halfVector[i]);
        NdotHV = max(dot(n, halfV), 0.0);
        currentColor += att * gl_FrontMaterial.specular * gl_LightSource[i].specular * 
                  pow(NdotHV, gl_FrontMaterial.shininess);
        color += currentColor;
      }
    }
  }

  return color;
}

